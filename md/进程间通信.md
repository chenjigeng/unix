# 进程间通信记录

1. 挂起并等待从多个源端的输入，当收到源端的输入或者超时，则进行处理。比如select和poll 

  ```javascript
  #include <stdio.h>
  #include <sys/time.h>
  #include <sys/types.h>
  #include <unistd.h>
  #include <fcntl.h>
  #include <stdlib.h>
  #include <string.h>

  #define BUFFER_SIZE 1024
  #define oops(m, x) {perror(m); exit(x);}

  void show_data(int fd);

  int main(int argc, char *argv[]){
    int fd1, fd2;  //两个文件描述符
    fd_set read_fds;  //select的read参数
    struct timeval timeout;  //超时设置
    int maxfd;
    int retval;

    if( (fd1 = open(argv[1], O_RDONLY)) == -1)
      oops("open", -1);

    if( (fd2 = open(argv[2], O_RDONLY)) == -1)
      oops("open", -1);
    // maxfd为需要监听的文件描述符最大的id+1
    maxfd = (fd1 > fd2) ? fd1 : fd2;
    maxfd++;
    
    while(1){
      // 清空描述符
      FD_ZERO(&read_fds);
      // 设置描述符
      FD_SET(fd1, &read_fds);
      FD_SET(fd2, &read_fds);
      // 设置超时时间
      timeout.tv_sec = atoi(argv[3]);
      timeout.tv_usec = 0;
      // 等待不同源的输入，或者超时，retval为-1, 说明有错误。为0，则表示超时。其他情况下，返回满足需求的文本描述符的数目
      retval = select(maxfd, &read_fds, NULL, NULL, &timeout);
      if(retval == -1)
        oops("select", -1);

      if(retval > 0){
        if(FD_ISSET(fd1, &read_fds))
          show_data(fd1);
        if(FD_ISSET(fd2, &read_fds))
          show_data(fd2);
      }else{
        //超时
        printf("time out......\n");
      }

    }
    return 0;
  }


  void show_data(int fd){

    int len;
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    len = read(fd, buffer, BUFFER_SIZE);
    if( len == -1 )
      oops("read", -1);

    write(1, buffer, len);
    write(1, "\n", 1);

  }
  ```

2. 通过文件的进程间通信:进程间可以通过文件来通信。某进程将数据写入文件，别的进程再从文件中读取数据。  
  **小结**  
  2.1 访问控制:客户端必须能够读取文件，服务端必须有写权限。  
  2.2 多客户端:任何数量的客户端都可以同时从文件中读取数据。  
  2.3 竞态条件:服务端是通过清空文件数据，再往里面写数据的方式来更新文件。如果客户端刚好在清空和重写之间读取文件，那么他可能得到一个空的或者只有部分内容。 避免竞态条件，服务端和客户端可以使用某种类型的互斥量（信号)来避免竞态条件。  

3. 命名管道：可以连接不相关的进程，并且独立于进程存在。称这样的管道叫做FIFO（先进先出队列）。  
  **小结**  
  3.1 访问：FIFO使用与通常文件相同的文件访问。服务器有写权限，客户端有读权限。  
  3.2 竞态条件：FIFO版本不存在竞态条件。在信息长度不超过管道的容量的情况下，read和write都是原子操作。读取操作将管道清空而写入操作将管道塞满。在读者和写着连通之前，系统内核将进程挂起，因此不需要锁机制。
  3.3 使用管道需要两次复制数据。write操作将数据从内存复制到内核缓存，read操作将数据从内核缓存复制到了内核。

4. 共享内存：共享的内存段是用户内存的一部分，每一个进程都有一个指向此内存段的指针。依靠访问权限的设置，所有的进程都可以读取这一块空间的数据，因此进程间的资源是共享的，而不是复制来复制去的。  
    基本概念：
    * 共享内存段在内存中不依赖于进程的存在而存在。
    * 共享内存段有自己的名字，成为关键字(key)。
    * 关键字是一个整型数。
    * 关键内存段有自己的拥有者以及权限位。
    * 进程可以连接到某共享内存段，并获取指向此段的指针。 

    **小结**  
    4.1 访问：共享内存段拥有一个权限系统，可以为用户、组合其他成员设置权限位，来控制他们各自的访问权限。因此，才可以让服务器有写权限而客户端只有读权限。  
    4.2 多个客户：任何数量的客户都可以同时从共享内存段读取数据。
    4.3 竞态条件：服务器通过调用一个strcpy函数来更新共享的内存段，若客户端正好在服务器向内存段写入新数据的时候访问内存段，那么它可能既读到新数据也遇到老数据。避免竞态条件，服务器和客户端必须使用相同的系统来对资源加锁。内核提供了一种进程间加锁的机制，成为客户端机制。

5. 管道：单向数据流动，写者向管道里写数据，读者从管道里读取数据。只能用在父子进程。
  基本概念:  
    * 管道读取阻塞：当进程试图从管道里读取数据的时候，进程被挂起，直到数据被写进管道里。
    * 管道的读取结束标志：当所有的写者关闭了管道的写数据端时，试图从管道读取数据的调用返回0，这意味着文件的结束。
    * 多个读者可能引起问题：管道是一个队列。当进程从管道里读取数据后，数据已经不存在了。这就会导致后面的读者读取不到之前的数据。
    * 写入数据阻塞直到管道有空间去容纳新的数据。
    * 写入必须保证一个最小的块大小
    * 若无读者在读取数据，则写操作执行失败。

## 两种类型的锁

1. 文件锁：对于通过文件的进程通信，由于可能存在竞态条件（服务器在写的时候，客户端正好在读取文件）。因此，我们可以采用文件锁的方式来解决这个问题。当服务器要写数据的时候，对文件加一个写文件锁。当客户端要读取数据的时候，对文件加一个读文件锁。写数据锁告诉其他进程，“我在写文件，完成之前任何人都必须等待。”
2. 信号量：对于共享内存的进程通信来说，如果防止某个进程在读取共享内存的时候，别的进程正在写这一块内存呢？我们可以使用信号量的方式来解决这个问题。信号量是一个内核变量，它可以被系统中的任何进程所访问。进程间可以使用这个变量来协调对于共享内存和其他资源的访问。

总结：

1. 信号量：此方法是面向消息的，多个无关进程间可以同时交互，但是只能在单机上工作。

2. 共享内存：此方法面向随机访问，多个无关进程间可以同时交互，但只能在单机上使用。

3. 文件锁： 这种方法面向消息，多个无关进程间可以同时交互，但只能在单机上工作。

4. 命名管道（FIFO）；此方法是单向传输的、面向流的。可以连接无关进程，但只能工作在单机上。

5. 共享文件：此方法面向随机访问，多个无关进程间可以同时交互，网络文件系统（NFS）可以支持跨机器的多进程通信。
